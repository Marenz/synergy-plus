#summary Formal specification document
#labels Phase-Implementation

<wiki:toc max_depth="2" />

= 1. Introduction =

Synergy+ is ideal for users with multiple computers, where each computer has a dedicated screen. Our application allows users to share their mouse and keyboard between multiple computers over a network. Synergy+ can be thought of as a _Software KVM_, except without video selection (as each computer must have a dedicated screen). To move between screens, simply move the mouse off the edge of one screen, and on to another.

Our application is cross platform, meaning that a combination of operating systems can be used together, such as Windows, Linux and Mac OS X. No special hardware is required to use Synergy+, just a local area network (LAN).

Synergy+ is a fork of Synergy2, meaning that our code is based on Synergy2 but with our own enhancements. The first version of Synergy was created on May 13, 2001 by Chris Schoeneman, et al. In future, we hope to merge with the Synergy2 project, and share the original Synergy name. This documentation will refer to our version of Synergy/Synergy2, as Synergy+ to avoid confusion between the 3 projects. Our aim is not to replace the original projects, but to collaborate with the original authors, and keep Synergy alive.

The first incarnation of synergy was !CosmoSynergy, created by Richard Lee and Adam Feder then at Cosmo Software, Inc., a subsidiary of SGI (nee Silicon Graphics, Inc.), at the end of 1996. They wrote it, and Chris Schoeneman contributed, to solve a problem: most of the engineers in Cosmo Software had both an Irix and a Windows box on their desks and switchboxes were expensive and annoying. !CosmoSynergy was a great success but Cosmo Software declined to productize it and the company was later closed. Synergy is a from-scratch reimplementation of !CosmoSynergy. It provides most of the features of the original and adds a few improvements.

A popular misconception is that Synergy+ works like a screen sharing application such as VNC, which is not true. Synergy+ manipulates only the keyboard and mouse input, and has nothing to do with the display so to speak.

In some respects, a traditional hardware KVM is more scalable because a hardware KVM can support _n_ computers on 1 screen, where as Synergy+ must have one screen for each computer. However, Synergy+ does have it's place as a niche product, because Synergy+ has a major benefit if a user requires one screen per machine.

== 1.2. Features ==

Synergy+ has a number of great features.

  * Sharing of mouse and keyboard over a local area network
  * Cross-platform support (Windows, Linux and Mac)
  * Free open source software
  * Online support community run by volunteers

== 1.3. Objectives ==

The current objectives of the Synergy+ project, in order of importance.

  # Fix all important bugs (http://code.google.com/p/synergy-plus/issues/list).
  # Current operating system support (especially for Windows).
  # A common user interface to all operating systems.
  # More intuitive setup/configuration and troubleshooting.

== 1.4. Community ==

See the [Community] page.

== 1.5. This Document ==

This document is maintained by the [Members documentation manager].

This document (the specification) was originally written for a PDF document, and was then converted in to wiki pages so all project members can make collaborative changes. The [SpecToctable of contents] can be used to find your away around the specification pages.

The specification contains:

  * The goals of this project
  * Important current bugs
  * System design and architecture

This is not an installation guide or user guide, and is intended for the project's community members.

=== 1.5.1. Guidelines ===

  * All specification material must be contained within the monolithic [Specification] page.
  * Each major section (Introduction, Design, etc.) must be separated by a horizontal rule (syntax: `----`).
  * The specification should be written from the 'we' and not the 'I' perspective.
  * Large diagrams must not be included in the page, and should be linked to instead.
  * Issues should not be added to the specification, and should be added to the [http://code.google.com/p/synergy-plus/issues/list issue tracker] instead.
  * Where an issue is detailed in the specification, it should be linked to by using the appropriate issue number.

=== 1.5.2. Diagrams ===

For creating diagrams, [http://projects.gnome.org/dia/ Dia] is the recommended application.

Dia is available as Ubuntu package (Add/Remove) or for [http://dia-installer.de/index_en.html Windows]. For Windows users, Dia is fairly similar for Visio, but Dia is a little more robust and is cross-platform (so can be used by all community members).

The .dia file should be saved in our source code repository under `/doc/diagrams`, so that others may edit it the diagram. To publish, the file should be exported to JPEG and added to the Wiki under the relevant specification page (usually SpecDesign).

== 1.6. Terminology ==

|| *Term* || *Meaning* ||
|| Synergy	|| The original version of Synergy, replaced by Synergy2 ||
|| Synergy2 || A fork of Synergy (we think) which is now seen as the official version ||
|| Synergy+ || Our fork of of Synergy2, which we hope to merge with Synergy/Synergy2 ||
|| GPL || GNU General Public License (we use version 2) ||
|| FOSS || Free Open Source Software (our project is FOSS) ||
|| Client || An instance of synergyc (the Synergy Client) ||
|| Server || An instance of synergys (the Synergy Server) ||

----

= 2. Analysis =

This section details analysis of the existing system (based on Synergy2) and key issues surrounding the current code and design. Before making any major changes we must first analyze the existing Synergy2 source code, as none of us know exactly how it works.

== 2.1. Diagrams ==

|| *Name* || *Detail* ||
|| [http://synergy-plus.googlecode.com/svn/trunk/doc/diagrams/ClientInit.jpeg Initialization] || Shows how the client is initialized. ||

The objective of creating these diagrams is to provide a clear map for use during development for all project members. Project members are encouraged to create their own diagrams and post them here. There is a [SpecPlan#Diagrams guide] on writing diagrams.

== 2.3. Logging ==

The logging system works by having a static singleton instance of `CLog` (`lib/base/CLog.h`) to which, "log outputters" are added. The outputters are defined in `lib/base/LogOutputters.h`, and are all derived from `ILogOutputter`.

  * `CConsoleLogOutputter` writes to the console when the application is launched in foreground mode (all platforms).

  * `CBufferedLogOututter` sends output to a Microsoft Windows, xwindows, or Carbon task bar. It writes to it's own internal buffer, which is displayed to the user on request.

  * `CMessageBoxOutputter` writes to the ms windows log message window; by default only on `FATAL` and similar. As a special case, this isn't defined in `LogOutputters.h`, but is defined in `synergyc.cpp`.

  * `CSystemLogOutputter` calls `ARCH->writeLog(...)` when the `write(...)` function is called.

  * `CStopLogOutputter` can be inserted to the CLog instance to stop it from logging to any further outputters.

----

= 3. Design =

This section focuses on the existing architecture, code style, and features. Where necessary, improvements on each feature will be suggested.

== 3.1. Limit of Scope ==

This is a list of features we really don't think we should implement (at least within the near future). Any features added, changed or removed from here should be debated in the mailing list. If there is a related issue with the `WontFix` label, then this issue should be referenced here.

  * Dragging windows between screens (Issue 21), or any sort of RDP application sharing (Issue 32).

== 3.2. Architecture ==

This section describes the current architecture. It should be read by developers who wish to plan new features, or improvements to existing features.

== 3.3. Features ==

This section describes both features that already exist (and are to be improved), and features that are to be implemented. Architecture should be consulted before hand.

=== 3.3.1. Network Cases ===

Many computers do have two network interfaces LAN/WLAN and it would be convenient for the user if they could define multiple address for the same client/server. The most common scenario is the one with the laptop docking stations.

|| *Case* || *Details* ||
|| A ||| Two Windows computers on the same LAN. ||
|| B || One laptop that is server having multiple configurations. ||
|| C || Computers connected on different subnets. ||
|| D || One client having multiple possible servers. ||

For case B, an example would be: Work; one client to the right. Home; another client in the left.

In case C, for example, one computer may be on the normal LAN subnet, but the other computer may be on a separate WLAN subnet.

Case D can happen if the user has a laptop that is shared inside one organization. It should be very easy to switch between servers on the client. _Note:_ It is possible to run multiple client instances, but this may not be ideal.

----

= 4. Implementation =

== 4.1. Rules ==

  * Do not put your name at the top of source code files.
  * All source code is owned by the Synergy+ project, not individuals.
  * Any code taken from Synergy2 must clearly state the original author.

== 4.2. Code style ==

The code style is based on the original style used by Chris Schoeneman. This original style will be followed for constancy, which will make it easier for the community to worth with.

=== Tabs are used for indentation not spaces ===
{{{
\t printf("hello world"); // correct
\s\s\s\s printf("hello world"); // incorrect
}}}
Some common sense required here: Where \s is a space, and \t is a tab. In this example, space after the \s and \t annotations, and the annotations themselves have been used for illustration; these should not be included in the actual code.

=== Class, struct, and enum names are `PascalCase` ===
{{{
class MyClass { };
struct MyStruct { };
enum MyEnum { };
}}}

=== Member, and enum constant names are (lower) `camelCase` ===
{{{
class MyClass {
public:
    void helloWorld();
};
}}}

=== Member variables (public and private) begin with `m_` ===
{{{
class MyClass {
public:
    MyClass* m_myClass1;
private:
    MyClass* m_myClass2;
};
}}}

=== Enum constants are prefixed with `k` ===
{{{
enum MyEnum {
    kValue1,
    kValue2
};
}}}

=== Static variables are prefixed with `s_` ===
{{{
static MyClass* s_myClass;
}}}

=== Comments and debug messages need not be grammatically correct ===
{{{
// i'm using bad grammar. but i like to use full stops
DEBUG((CLOG_INFO "hello world"));
}}}

=== Multiline comments use single-line commenting (`//`) ===
{{{
// for long block comments, instead of using the slash asterisk
// comments, we use the two-slash comments
}}}

=== Function return types must go on the line above the function name ===
{{{
// correct
int
MyClass::helloWorld()
{
}

// incorrect
int MyClass::helloWorld()
{
}
}}}

=== For functions, curly braces start on the next line after the function name ===
{{{
// correct
int
MyClass::helloWorld()
{
    // ...
}

// incorrect
int
MyClass::helloWorld() {
    // ...
}
}}}

=== For conditional statements, curly braces start on the same line ===
{{{
// correct
if (a == b) {
    // ...
}

// correct
for (int i = 0; i < a; i++) {
    // ...
}

// incorrect
if (a == b)
{
    // ...
}

// incorrect
for (int i = 0; i < a; i++)
{
    // ...
}
}}}

=== A space is used between operators and operands ===
{{{
// correct
a == b;
if (c == d) {
}

// incorrect
a=b;
if (c==d) {
}
}}}

=== No space is inserted after or before conditions within parenthesis ===
{{{
// correct
if (a == b) {
    // ...
}

// incorrect
if ( a == b ) {
    // ...
}
}}}

=== The void keyword is not used for functions that do not take parameters ==
{{{
// correct
void helloWorld();

// incorrect
void helloWorld(void);
}}}

=== The const keyword is used regularly ===
{{{
class MyClass {
public:
    const char* helloWorld();
};

MyClass::MyClass(const char* helloWorld)
{
}
}}}

=== Spaces must exist between conditional statement parenthesis and the keyword ===
{{{
// correct
if (a == b) {
}

// incorrect
if(a == b) {
}
}}}

=== No spaces between type and reference and pointer operator ===
{{{
// correct
char* helloWorld;

// incorrect
char *helloWorld;
}}}

=== Pre-processor commands within #if are indented ===
{{{
// correct
#if HELLO_WORLD
#    include "HellWorld.h"
#endif

// incorrect
#if HELLO_WORLD
#include "HellWorld.h"
#endif
}}}

=== Pointers and references do not have prefixes ===
{{{
// correct
MyClass* myClass1 = new MyClass();
MyClass& myClass2 = *myClass1;

// incorrect
MyClass* p_myClass1 = new MyClass();
MyClass& p_myClass2 = *p_myClass1;

// incorrect
MyClass* pMyClass1 = new MyClass();
MyClass& pMyClass2 = *pMyClass1;
}}}

=== The left comparator operand is a variable ===
{{{
// correct
if (a == "hello world") {
}

// incorrect
if ("hello world" == a) {
}
}}}
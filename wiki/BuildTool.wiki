#summary A review of possible replacement build tools
#labels Deprecated

= Attention! =

Since this page is no longer required, it has been deprecated. However, it can still be referenced if it's useful to others outside the project. We have chosen CMake as our new build tool, after a lengthy [http://groups.google.com/group/synergy-plus/browse_thread/thread/2b41cbdf1a80168e discussion] and unanimous vote in favour of CMake. [Compiling Finished instructions] for using our CMake implementation are now available. The test branches mentioned in earlier versions of this page no longer exist.

= Summary =

<wiki:toc max_depth="2" />

We've decided to choose from either [http://www.cmake.org/ CMake], [http://scons.org/ SCons], or [http://code.google.com/p/swtoolkit/ swtoolkit].

*CMake is:*
  * The most mature, and so more compatible;
  * Used by bigger projects (e.g. KDE, MySQL);
  * Has more recent stable releases.

*SCons is:*
  * Very flexible (uses Python for build config);
  * Slightly under-maintained (stable release is quite old);
  * Has limited IDE project generator support.

*swtoolkit is:*
  * An extension to SCons;
  * Makes SCons more bearable;
  * Maintained by a team from Google.

CMake generates the build chain config for the current platform. So, if Mac or Linux, it will create `Makefile` files by default, which can be used by `make`. On a Windows system, it can create a Visual Studio project, so the developer can build and debug from there using the native Visual Studio build system. The advantage here is that developers can use build tools that they're already familiar with; such as `make`, Visual Studio, and Xcode (to name a few). As well as the default behaviour, the `-G` argument can be used to generate projects for Code::Blocks, KDevelop, Eclipse CDT, etc.

SCons will build the project it's self rather than relying on native build chains, using the compiler tools available (e.g. `g++` or `cl.exe`). It can generate Visual Studio projects, but the support isn't as good as with CMake. However, in terms of configuration, over all SCons appears to be a more elegant, since build config scripts are written in Python. Installation on Linux is easy; it's just a case of `sudo apt-get install scons` or on Mac with Macports, `sudo port install scons`. On Windows, this is a bit more tricky; for example, the developer needs to manually set their SCONS_DIR environment variable - but, swtoolkit fixes this, sort of.

Software Construction Toolkit (swtoolkit) implements SCons. It can either implement the version of scons installed on the system, or a resident SCons version bundled with the project (in our case, we put it in the `./contrib/` dir). Because it implements SCons, it has all of the pros and cons of SCons (meaning that it inherits the not-so-great project generator support).

== CMake ==

=== Pros ===

  * Most active; latest stable release: 2.6.4 / 2009-05-01;
  * Generates projects for: Makefiles, Visual Studio 2008/2005, Xcode, Code::Blocks, etc;
  * Visual Studio, and `make` automatically re-check the CMake config files;
  * Config files seem to be smaller and less complicated;
  * Generates Visual Studio projects in a more familiar and native way (unlike SCons);
  * Easier to install on Windows (less dependencies);
  * Uses Visual Studio's native method of compiling, which feels faster than SCons';
  * Can generate Mac OS X packages (implements Apple's !PackageMaker);
  * Can generate Windows installers (using NSIS) without problems, unlike SCons;
  * The KDE project use it, _so you know it's good_.

=== Cons ===

  * The version available as of writing this does not detect the installed version of Visual Studio 2008 (version 9). Users will get an error similar to: Cannot find Visual Studio 6;
  * Cannot generate a make-compatable `.tar.gz` source archive (i.e. with `./configure` script) - but, neither can SCons - however, it can generate a source package (with `cmake package_source`) which is similar to that generated by `make dist`;
  * Config files are .txt, so most editors won't support syntax highlighting and auto completion, since .txt isn't associated with a particular language;
  * Checking for libraries (using CHECK_LIBRARY_EXISTS) is a little more complicated compared to SCons, since it requires you to specify a function (with SCons, all you need to do is tell it the library name) - however, this could be considered a good thing, since some libraries have the same name, but have different functions (this doesn't apply to us right now, but could in future);
  * For Visual Studio and Xcode projects, CMake puts all the source files in one directory irrespective of the original directory structure; for example, the `synergy` library is separated into about 10 folders (for neatness) but now they're all in one place which makes it hard to find what you need if you're unfamiliar with the system (not sure if this can be fixed);

== SCons ==

=== Pros ===

  * Uses Python scripts for configuration;
  * Same command to compile on all platforms;
  * Doesn't rely on an external build chain;

=== Cons ===

  * Least active; latest stable release: 1.2.0 / 2008-12-20;
  * Does not automatically add SCONS_DIR environment variable during setup;
  * The MSI package tool is very buggy (had to manually implement WiX using Python);
  * Cannot create `.deb` (Debian package) or `.dmg` (Mac image) - only `.rpm` is supported;
  * Cannot generate Xcode projects (no intrinsic support);
  * Only supports Visual Studio 2005 (no 2008 support);
  * Visual Studio compiler support is broken in *stable* version (cannot find path to compiler, linker, libraries and headers by default);
  * Cannot generate both Debug and Release configurations for the same VS projects, where as CMake can, which is quite handy;
  * Does not use Visual Studio to build the project directly (i.e. it's not used as a build chain), and instead Visual Studio calls the `scons` command which then calls `cl`, etc;
  * Apparently, the main contributor (Steven Knight) is busy with other projects, which appears to have made development slow down (obviously this may change at a moments notice);
  * On Windows, `scons` seems to take longer to compile than Visual Studio would if it were compiling directly as opposed to compiling via `scons`;
  * If we don't bundle SCons, we're asking users to install it, and the installed version might not be compatible (CMake is more likely to be compatible since KDE and other projects made it very widespread);
  * If we bundle it, changes in Python might break it (Python 2.6 broke lots of SCons-based build systems in Gentoo);
  * There is no standard way to handle flags and options, which also becomes a burden for distributions, and if distributions don't include our software in their repositories, it will be less popular;
  * The waf/bksys "standardised" build systems made very huge mess in the past because people tried to make up build systems with not nearly enough knowledge of different systems; for instance the libtool-emulation `.la` files generation creates very broken `.la` files in a system;
  * Cannot generate a make-compatable tar.gz source archive (i.e. with `./configure` script) - but, neither can CMake;

== swtoolkit ==

The pros and cons here refer to having SCons bundled with the project (in `./contrib/`), which overcomes some of the SCons cons.

=== Pros ===

  * Has all or most the advantages of SCons;
  * Because the tool is started with `hammer.bat` or `./hammer.sh` (in the project root), this allows us to include SCons with the project (under `./contrib/`) and use that instead of the user installed version, ensuring that the version of SCons used works with the config files. This also means that the developer does not need to install scons (one less dependency);

=== Cons ===

  * Has all or most the disadvantages of SCons;
  * The generated Visual Studio projects look for a system installed `scons`, meaning that we can't use the bundled SCons version in `./contrib/` to compile using Visual Studio;

== Why change? ==

  * Automake is not straight forward to use with Windows; though it is supported, it requires some extra configuration to set up, and most Windows developers want to use Visual Studio anyway.
  * Automake is unable to generate IDE projects, such as Visual Studio and Xcode, and the GNU project probably won't ever have such features.
  * With Automake, we are forced to update each of Makefile.am files, Visual Studio project and Xcode project every time we add or remove a source file.

Because Synergy+ is a cross-platform project, we must support developers who use any of Windows, Linux or Mac as their native system. As well as having the Automake config, we can manually create IDE projects by hand, in fact we have done this for Visual Studio 2005 and 2008 projects. The problem is, that once you have more than one source file list, keeping all these lists synchronised becomes time consuming and is prone to human error.

However, we cannot abandon use Automake completely, because many Linux distributions require software to have `./configure` script (which is generated by Automake). For example, the [https://wiki.ubuntu.com/PackagingGuide/Complete Ubuntu packaging guide] details the `./configure` file as a prerequisite.

The solution is to use a build tool which can do the following:

  * One script that can run on all platforms (or a `.sh` and `.bat`).
  * Generate the `./configure` script (which generates `Makefile`, used by `make`)
  * Generate Visual Studio 2005 and 2008 projects for our Windows developers
  * Generate  Xcode projects for our Mac developers
  * Build the software (one command for all platforms)

The build system must work the same on all supported platforms:

  * Windows
  * Linux
  * Mac OS X

So far we have been [http://spreadsheets.google.com/ccc?key=pMmqebSYIv8CSsSTN114BLA&hl=en voting] on the best tool to use, and it seems to be falling on either [http://code.google.com/p/swtoolkit/ swtoolkit] or [http://www.cmake.org/ CMake]. The former is the favourite of our project leader, and the later is more well known in the open source community.

== KDE didn't choose SCons? ==

From the artcle, [http://lwn.net/Articles/188693/ Why the KDE project switched to CMake -- and how (continued)]...

The principal move away from autoconf, automake, configure, libtool & friends was decided at last year's annual KDE conference, akademy. KDE developers at the time discussed and evaluated several alternatives: back then, SCons (a Python-based build tool) was favored, spiced up with a KDE-wrapper called bksys to help with the actual work. SCons/bksys already worked well for a number of developers who used it in their sub-projects, and the tandem seemed to easily win the race. Up until January 2006, several people worked hard on replacing the existing autotools based build system of KDE3 with SCons/bksys for KDE4. Their first acid test was to make it compile kdelibs on various platforms.

However, various hurdles showed up unexpectedly. The KDE individuals who tried to bring SCons into a shape that made it fit for building such a huge project felt they didn't have any support from the upstream SCons developers. There were major problems building KDE on non-Linux platforms with SCons (e.g. on OS X); in general they felt it did not yet have a mature configuration system. The only option down that road was to create major SCons fixes and patches on their own. Since these changes would not likely be included in the upstream sources, it would require permanent maintenance of the fixes in a separate repository. In effect, this would have amounted to a fork of SCons. KDE developers would have had to maintain the new build system entirely on their own. So the rosy SCons/bksys image paled again....
\documentclass{article}
\usepackage{hyperref}

\setlength{\parindent}{0pt} 
\setlength{\parskip}{2ex}

\title{Synergy 2 Specification}
\author{Nick Bolton}

\begin{document}

\maketitle

\section{Synopsis}

Synergy needs rewriting from scratch in order to provide a long term fix for 
bugs such as the ``sticky keys'' issue. It is difficult to fix bugs in the
current version of Synergy without causing regressions.

This document is our first step toward designing version 2 of Synergy, so it's
very much a work in progress.

\section{License}

We should use a license that allows companies to include Synergy as part of an 
existing product, but not on it's own (if there is such a license). This might
be the New BSD License (or GPLv3 if it allows commercial redistribution).

\section{Requirements}

\subsection{Fully Supported}

\begin{itemize}
  \item Windows XP SP3
  \item Windows Vista SP1
  \item Windows 7
  \item Windows 2003 Server
  \item Ubuntu 10.04
  \item Fedora 13
  \item openSUSE 11.3
  \item Mac OS 10.4 Tiger
  \item Mac OS 10.5 Leopard
  \item Mac OS 10.6 Snow-Leopard
\end{itemize}

\section{Unsupported}

These systems are explicitly not supported.

\begin{itemize}
  \item Windows NT family (e.g. 2000, etc)
  \item Windows 95 family (e.g. 98/ME)
\end{itemize}

\section{Methodology}

Many developers before now have vowed to rewrite Synergy. Unfortunately though,
it has never materialized due to lack of motivation and momentum. To solve 
this problem, we should use Scrum which will allow us to deliver features in
small bursts.

\subsection{Unit Testing}

Open source software should be easy for new developers to modify without too
much risk of breaking things. Currently, applying patches is very risky, since 
this usually causes regressions. Unit testing would help us identify regressions
before the end-user does.

However, some aspects of Synergy are difficult to test, since it always requires
more than one machine to function. We can emulate this behavior on a single 
machine by running both the server and client (so that they communicate 
locally), but this only allows us to test the network layer (not the mouse,
keyboard, clipboard, and so on).

\textbf{Nightly integration testing} (as unit tests) on a build machine can 
simulate a fully fledged environment involving many \textit{real} machines. The 
contributor would never run these tests before committing (it wouldn't be 
practical), but it will help detect problems early enough.

\subsection{User Stores}

The problem with defining stories for multi-platform, client-server software
is that most features must be implemented once for each platform, then for both
client and server (even more so when the software is integrated tightly with
each platform). This means we need to implement many stories 6 times.

\textbf{As a user:}

\begin{itemize}
  \item I want to move my server mouse to a client computer (and back) so that 
    I only need one mouse.
  \item I want keys pressed on the server to go to the same computer as the
    mouse cursor so that I only need one keyboard.
  \item I want data copied to my clipboard to replicate to the computer which
    I move my cursor to, so that I can copy data between computers.
  \item I want screen savers on all connected computers to start at the same time
    so that all screens stay on while I'm working.
\end{itemize}

\textbf{For each:}

\begin{itemize}
  \item Windows server
  \item Windows client
  \item Linux server
  \item Linux client
  \item Mac OS X server
  \item Mac OS X client
\end{itemize}

With these very simple looking user stories, we should be able to make a good 
start.

\section{Language}

Our language of choice will be C++. However, we might want to consider writing
the GUI in Python (Chris's idea).

Regardless, we should separate the core system layer and the GUI layer via IPC,
so that we can use either C++ or Python.

\subsection{Libraries}

We should use Boost to increase productivity; typically an application would
take longer to write in C++ because the standard library has less functionality
available to the developer - so they spend more time reinventing-the-wheel.

\subsection{Toolchain}

Historically, automake was used before Synergy+ came along and started using
CMake (each have pros and cons). Because CMake is a little limited, a hm.py 
script was created to extend the toolchain so that less input from the developer
was required.

\subsection{Code Style}

We'll use the code style from version 1, with a few modifications. We should 
drop the C-prefix class naming convention (adopted from MFC). See appendix A 
for full guide.

\section{Debugging}

Debugging Synergy is quite difficult, since doing so requires the use of the 
same mouse and keyboard that Synergy is using. Let's say we break in the 
function that handles cursor movements, often doing so will cause the mouse
to freeze for a while until the hook is released automatically.

We should design version 2 so that it is easy to debug and test features. It
might be that the existing code runs the HID input handling in a separate 
thread -- in this case, we need to make it obvious in our documentation not to 
break all threads (and how to do this in various debuggers).

\section{Logging}

Logging is very important for post-mortem analysis, but is also useful during
development since it can be so difficult to debug. File logging should be 
enabled by default, with only warnings and errors, with some form of log 
rotation to conserve user disk space.

\section{Design Scope}

With a tool as conceptually simple as Synergy, it's very easy to get carried
away with feature requests. Some features we should not plan to include:

\begin{enumerate}
  \item Dragging windows between screens.
  \item Remote audio sharing.
  \item Connecting over the Internet.
  \item Smart phone or tablet as server.
  \item Remote desktop integration.
\end{enumerate}

\section{GUI Design}

While version 1 is simple to setup, it can be a little difficult to
troubleshoot. As command-line tools go, the existing version is great, but
can be a little involved for some users. Often these users are from a Windows
or Mac background where tool configuration is usually done with an intuitive
GUI.

Version 1 was originally designed as a command line tool, then later on, several
GUI applications were invented to try and make configuration easier. QSynergy is
one of those GUIs that found a good balance of cross-platform support and user 
friendliness. However, like all Synergy GUIs, it is limited by the lack of 
interoperability with the underlying command line utility. So we should design 
version 2 with IPC to the GUI firmly in mind.

\subsection{Wizard}

While we should support the existing config file format, some would prefer a
setup wizard to simplify the process. The wizard should display immediately
after installation on all platforms (with the option to skip the wizard). When
the wizard starts, the user should choose whether the machine is a client or a
server (the wizard should explain the difference).

\subsubsection{Server steps}
\begin{enumerate}
  \item Show instructions for starting client wizard(s).
  \item Show connected clients in a status list (as they connect).
  \item Allow user to advance once all clients have connected.
  \item Allow user to drag and drop clients on a grid.
  \item Save config to file (at custom location) when complete.
\end{enumerate}

Often, the user's hostname will not be found on their DNS server, and in such
a case we should detect this, and ask the user to use an IP instead.

\subsubsection{Client steps}
\begin{enumerate}
  \item Prompt the user for the server hostname or IP (shown in server wizard).
  \item If unable to connect, show troubleshooting tips.
\end{enumerate}

Troubleshooting steps might include asking the user to temporarily turn off
their firewall, try pinging, etc. This will reduce the number of troubleshooting
requests coming into the website and mailing list.

\appendix
\section{Code Style}

\subsection{Major differences in version 2}

If you're already familiar with the version 1 syntax, then here's all you need
to know:

\begin{enumerate}
  \item No C prefix on classes.
  \item 2 space indentation, not tabs.
  \item Put function modifiers on the same line.
\end{enumerate}

\subsection{Space indentation}

\begin{verbatim}
\s\s printf("hello world"); // correct
\t printf("hello world"); // incorrect
\end{verbatim}

\subsection{Class, struct, and enum names are PascalCase}

\begin{verbatim}
class MyClass { };
struct MyStruct { };
enum MyEnum { };
\end{verbatim}

\subsection{Member, and enum constant names are lower camelCase}

\begin{verbatim}
class MyClass {
public:
    void helloWorld();
};
\end{verbatim}

\subsection{Member variable prefix}

\begin{verbatim}
class MyClass {
public:
    MyClass* m_myClass1;
private:
    MyClass* m_myClass2;
};
\end{verbatim}

\subsection{Enum constants are prefixed with k}

\begin{verbatim}
enum MyEnum {
    Value1,
    Value2
};
\end{verbatim}

\subsection{Static variable prefix}

\begin{verbatim}
static MyClass* s_myClass;
\end{verbatim}

\subsection{Comments and debug messages need not be grammatically correct}

\begin{verbatim}
// i'm using bad grammar. but i like to use full stops
DEBUG((CLOG_INFO "hello world"));
\end{verbatim}

\subsection{Multiline comments use single-line commenting (//)}

\begin{verbatim}
// for long block comments, instead of using the slash asterisk
// comments, we use the two-slash comments
\end{verbatim}

\subsection{Function return types must go on the line above the function name}

\begin{verbatim}
// correct
int MyClass::helloWorld() {
  // ...
}

// incorrect
int
MyClass::helloWorld() {
  // ...
}
\end{verbatim}

\subsection{Curly braces start on the same line as the function}

\begin{verbatim}
// correct
int MyClass::helloWorld() {
  // ...
}

// incorrect
int MyClass::helloWorld()
{
  // ...
}
\end{verbatim}

\subsection{Curly braces start on the same line for statements}

\begin{verbatim}
// correct
if (a == b) {
    // ...
}

// correct
for (int i = 0; i < a; i++) {
    // ...
}

// incorrect
if (a == b)
{
    // ...
}

// incorrect
for (int i = 0; i < a; i++)
{
    // ...
}
\end{verbatim}

\subsection{A space is used between operators and operands}

\begin{verbatim}
// correct
a == b;
if (c == d) {
  // ...
}

// incorrect
a=b;
if (c==d) {
  // ...
}
\end{verbatim}

\subsection{No space is inserted after or before conditions within parenthesis}

\begin{verbatim}
// correct
if (a == b) {
    // ...
}

// incorrect
if ( a == b ) {
    // ...
}
\end{verbatim}

\subsection{Don't use void keyword for functions with no parameters}

\begin{verbatim}
// correct
void helloWorld();

// incorrect
void helloWorld(void);
\end{verbatim}

\subsection{The const keyword is used regularly}

\begin{verbatim}
class MyClass {
public:
    const char* helloWorld();
};

MyClass::MyClass(const char* helloWorld)
{
  // ...
}
\end{verbatim}

\subsection{Space between statement parenthesis and the keyword}

\begin{verbatim}
// correct
if (a == b) {
  // ...
}

// incorrect
if(a == b) {
  // ...
}
\end{verbatim}

\subsection{No spaces between type and reference and pointer operator}

\begin{verbatim}
// correct
char* helloWorld;

// incorrect
char *helloWorld;
\end{verbatim}

\subsection{Pre-processor command indentation}

\begin{verbatim}
// correct
#if HELLO_WORLD
#include "HellWorld.h"
#endif

// incorrect
#if HELLO_WORLD
#  include "HellWorld.h"
#endif
\end{verbatim}

\subsection{Pointers and references do not have prefixes}

\begin{verbatim}
// correct
MyClass* myClass1 = new MyClass();
MyClass& myClass2 = *myClass1;

// incorrect
MyClass* p_myClass1 = new MyClass();
MyClass& p_myClass2 = *p_myClass1;

// incorrect
MyClass* pMyClass1 = new MyClass();
MyClass& pMyClass2 = *pMyClass1;
\end{verbatim}

\subsection{The left comparator operand is a variable}

\begin{verbatim}
// correct
if (a == "hello world") {
  // ...
}

// incorrect
if ("hello world" == a) {
  // ...
}
\end{verbatim}

\subsection{The else statement on the same line as the curly brace}

\begin{verbatim}
// correct
if (a == b) {
  // ...
} else {
  // ...
}

// incorrect
if (a == b) {
  // ...
}
else {
  // ...
}
\end{verbatim}

\end{document}

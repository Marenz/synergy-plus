\documentclass{article}
\usepackage{hyperref}

\setlength{\parindent}{0pt} 
\setlength{\parskip}{2ex}

\title{Synergy 2 Specification}
\author{Nick Bolton}

\begin{document}

\maketitle

\section{Synopsis}

Synergy needs rewriting from scratch in order to provide a long term fix for 
bugs such as the ``sticky keys'' issue. It is difficult to fix bugs in the
current version of Synergy without causing regressions. With this rewrite, we
will use a specific methodology in order to make the software more robust.

\section{License}

We will use a license that allows companies to include Synergy as part of an 
existing product, but not on it's own (if there is such a license). This might
be the New BSD License (or GPLv3 if it allows commercial redistribution).

\section{Requirements}

\subsection{Fully Supported}

\begin{itemize}
  \item Windows 7
  \item Windows Vista SP1
  \item Windows XP SP3
  \item Windows 2003 Server
  \item Ubuntu 10.04
  \item Fedora 13
  \item openSUSE 11.3
  \item Mac OS 10.6 Snow Leopard
  \item Mac OS 10.5 Leopard
  \item Mac OS 10.4 Tiger
\end{itemize}

\section{Unsupported}

These systems are explicitly not supported.

\begin{itemize}
  \item Windows NT family (inc. 2000, etc)
  \item Windows 95 family (inc. 98, ME, etc)
\end{itemize}

\section{Methodology}

Many developers before now have vowed to rewrite Synergy. Unfortunately though,
the intention has never materialized due to lack of motivation, involvement from
the community, and momentum.
To solve this problem, we should plan the new version thoroughly and use the
Scrum Agile methodology which will allow us to deliver features in small 
bursts (which will maintain momentum and community interest).

In version 1, we use Buildbot for the nightly build, so this can be used to run
the integration tests (as explained later in this section) as well as standard 
unit tests (which are also run by developers).

\subsection{Unit Testing}

Open source software should be easy for new developers to modify without too
much risk of breaking the existing functionality. Currently, applying patches 
is very risky, since this usually causes regressions. Unit testing will help 
developers identify regressions before we check code in.

However, some aspects of Synergy are difficult to test, since it always requires
more than one machine to function. We \textit{could} emulate this behavior on a 
single machine by running both the server and client (so that they communicate 
locally), but this only allows us to test the network layer (not the mouse,
keyboard, clipboard, and so on). The solution is to use integration testing
\ldots

\subsection{Integration Testing}

Nightly integration testing (in the form of unit tests) will be run on on the 
Buildbot build machines, and will
simulate a fully fledged environment involving many \textit{real} machines. The 
contributor would never run these tests before committing (it wouldn't be 
practical), but it will help detect problems early enough.

In each test environment, there will be 3 Buildbot slaves (1 server, 2 clients).
To run a test, the Buildbot slaves must make some assumptions; that the clients
can communicate with the server via LAN, and that they are all turned on at the 
same time (we will have to do this via a Buildbot schedule). Since we'd be 
making timing assumptions, there is a large margin for error, so the test node
sync operation must produce helpful errors (and check the environment fully).

All integration test cases must be implemented \textbf{before} we start 
implementing any functionality (otherwise they might never get set up).

Each unit test should do the following:

\begin{enumerate}
  \item Synchronize with all other nodes.
  \item Start either a client or server.
  \item Either wait for client connections, or connect to the server.
  \item Have the server test node move the mouse ``off the screen''.
  \item Pass or fail depending on whether or not client mouse pointer has
    actually moved to the expected coordinates.
\end{enumerate}

We must design this test each time for testing the clipboard, keyboard input,
screensaver sync, and all other major features.

Each test should run once for every possible combination of platform. For 
example:

\begin{itemize}
  \item Windows server, Linux client, Mac OS X client.
  \item Windows server, 2 Windows clients.
  \item Linux server, Windows client, Mac OS X client.
  \item \ldots
\end{itemize}

\subsection{User Stores}

The problem with defining stories for multi-platform, client-server software
is that most features must be implemented once for each platform, then for both
client and server (even more so when the software is integrated tightly with
each platform). This means we need to implement many stories up to 6 times.

\textit{Note: This is not an exhaustive list of features.}

\textbf{As a user:}

\begin{itemize}
  \item I want to move my server mouse to a client computer (and back) so that 
    I only need one mouse.
  \item I want keys pressed on the server to go to the same computer as the
    mouse cursor so that I only need one keyboard.
  \item I want data copied to my clipboard to replicate to the computer which
    I move my cursor to, so that I can copy data between computers.
  \item I want screen savers on all connected computers to start at the same
    time so that all screens stay on while I'm working.
  \item \ldots
\end{itemize}

\textbf{For each:}

\begin{itemize}
  \item Windows server
  \item Windows client
  \item Linux server
  \item Linux client
  \item Mac OS X server
  \item Mac OS X client
\end{itemize}

With these very simple looking user stories, we should be able to make a good 
start, but even the first release must work (if only with little platform
support).

\section{Implementation}

\subsection{Language}

Our language of choice will be C++ as with version 1. However, we might want to
consider writing the GUI in Python (Chris's idea). Regardless, we should 
separate the core system layer and the GUI layer via IPC, so that we can use
any language to write the GUI.

\subsection{Libraries}

We should use Boost to increase productivity; typically an application would
take longer to write in C++ because the standard library has less functionality
available to the developer - so we spend more time reinventing-the-wheel.

\subsection{Toolchain}

Historically, Automake was used before Synergy+ came along and started using
CMake (each have pros and cons). Because CMake is a little limited, a hm.py 
script was created to extend the toolchain so that less input from the developer
was required.

\textbf{TODO:} Should we stick with the Synergy+ way?

\subsection{Code Style}

We'll use the code style from version 1, with a few modifications. For example 
we will drop the C-prefix class naming convention (adopted from MFC). See 
appendix A for the full guide.

\subsection{Debugging}

Debugging Synergy is quite difficult, since doing so requires the use of the 
same mouse and keyboard that Synergy is using. Let's say we break in the 
function that handles cursor movements, often doing so will cause the mouse
to freeze for a while until the hook is released automatically.

We should design version 2 so that it is easy to debug and test features. It
might be that the existing code runs the HID input handling in a separate 
thread -- in this case, we need to make it obvious in our documentation not to 
break all threads (and how to do this in various debuggers).

\subsection{Logging}

Logging is very important for post-mortem analysis, but is also useful during
development since it can be so difficult to debug. File logging should be 
enabled by default for the end-user, with only warnings and errors, with some
form of log  rotation to conserve user disk space.

\section{Design}

\subsection{Scope}

With a tool as conceptually simple as Synergy, it's very easy to get carried
away with feature requests. Some features we should not plan to include:

\begin{enumerate}
  \item Dragging windows between screens.
  \item Remote audio sharing.
  \item Connecting over the Internet.
  \item Smart phone or tablet as server.
  \item Remote desktop integration.
\end{enumerate}

\subsection{GUI}

While version 1 is simple to setup, it can be a little difficult to
troubleshoot. As command-line tools go, the existing version is great, but
can be a little involved for some users. Often these users are from a Windows
or Mac background where tool configuration is usually done with an intuitive
GUI.

Version 1 was originally designed as a command line tool, then later on, several
GUI applications were invented to try and make configuration easier. QSynergy is
one of those GUIs that found a good balance of cross-platform support and user 
friendliness. However, like all Synergy GUIs, it is limited by the lack of 
interoperability with the underlying command line utility. So we should design 
version 2 with IPC to the GUI firmly in mind.

\subsection{Wizard}

While we should support the existing config file format, some would prefer a
setup wizard to simplify the process. The wizard should display immediately
after installation on all platforms (with the option to skip the wizard). When
the wizard starts, the user should choose whether the machine is a client or a
server (the wizard should explain the difference with a simple diagram).

\subsubsection{Server steps}
\begin{enumerate}
  \item Show instructions for starting client wizard(s).
  \item Show connected clients in a status list (as they connect).
  \item Allow user to advance once all clients have connected.
  \item Allow user to drag and drop clients on a grid.
  \item Save config to file (at custom location) when complete.
\end{enumerate}

Often, the user's hostname will not be found on their DNS server, and in such
a case we should detect this, and ask the user to use an IP instead.

\subsubsection{Client steps}
\begin{enumerate}
  \item Prompt the user for the server hostname or IP (shown in server wizard).
  \item If unable to connect, show troubleshooting tips.
\end{enumerate}

Troubleshooting steps might include asking the user to temporarily turn off
their firewall, try pinging, etc. This will reduce the number of troubleshooting
requests coming into the website and mailing list.

\appendix
\section{Code Style}

\subsection{Major differences in version 2}

If you're already familiar with the version 1 syntax, then here's all you need
to know:

\begin{enumerate}
  \item No C prefix on classes.
  \item 2 space indentation, not tabs.
  \item Put function modifiers on the same line.
\end{enumerate}

\subsection{Space indentation}

\begin{verbatim}
\s\s printf("hello world"); // correct
\t printf("hello world"); // incorrect
\end{verbatim}

\subsection{Class, struct, and enum names are upper camel case}

\begin{verbatim}
class MyClass { };
struct MyStruct { };
enum MyEnum { };
\end{verbatim}

\subsection{Member, and enum constant names are lower camel case}

\begin{verbatim}
class MyClass {
public:
    void helloWorld();
};
\end{verbatim}

\subsection{Member variable prefix}

\begin{verbatim}
class MyClass {
public:
    MyClass* m_myClass1;
private:
    MyClass* m_myClass2;
};
\end{verbatim}

\subsection{Enum constants are prefixed with k}

\begin{verbatim}
enum MyEnum {
    Value1,
    Value2
};
\end{verbatim}

\subsection{Static variable prefix}

\begin{verbatim}
static MyClass* s_myClass;
\end{verbatim}

\subsection{Comments and debug messages need not be grammatically correct}

\begin{verbatim}
// i'm using bad grammar. but i like to use full stops
DEBUG((CLOG_INFO "hello world"));
\end{verbatim}

\subsection{Multi-line comments use single-line commenting (//)}

\begin{verbatim}
// for long block comments, instead of using the slash asterisk
// comments, we use the two-slash comments
\end{verbatim}

\subsection{Function return types must go on the line above the function name}

\begin{verbatim}
// correct
int MyClass::helloWorld() {
  // ...
}

// incorrect
int
MyClass::helloWorld() {
  // ...
}
\end{verbatim}

\subsection{Curly braces start on the same line as the function}

\begin{verbatim}
// correct
int MyClass::helloWorld() {
  // ...
}

// incorrect
int MyClass::helloWorld()
{
  // ...
}
\end{verbatim}

\subsection{Curly braces start on the same line for statements}

\begin{verbatim}
// correct
if (a == b) {
    // ...
}

// correct
for (int i = 0; i < a; i++) {
    // ...
}

// incorrect
if (a == b)
{
    // ...
}

// incorrect
for (int i = 0; i < a; i++)
{
    // ...
}
\end{verbatim}

\subsection{A space is used between operators and operands}

\begin{verbatim}
// correct
a == b;
if (c == d) {
  // ...
}

// incorrect
a=b;
if (c==d) {
  // ...
}
\end{verbatim}

\subsection{No space is inserted after or before conditions within parenthesis}

\begin{verbatim}
// correct
if (a == b) {
    // ...
}

// incorrect
if ( a == b ) {
    // ...
}
\end{verbatim}

\subsection{Don't use void keyword for functions with no parameters}

\begin{verbatim}
// correct
void helloWorld();

// incorrect
void helloWorld(void);
\end{verbatim}

\subsection{The const keyword is used regularly}

\begin{verbatim}
class MyClass {
public:
    const char* helloWorld();
};

MyClass::MyClass(const char* helloWorld)
{
  // ...
}
\end{verbatim}

\subsection{Space between statement parenthesis and the keyword}

\begin{verbatim}
// correct
if (a == b) {
  // ...
}

// incorrect
if(a == b) {
  // ...
}
\end{verbatim}

\subsection{No spaces between type and reference and pointer operator}

\begin{verbatim}
// correct
char* helloWorld;

// incorrect
char *helloWorld;
\end{verbatim}

\subsection{Pre-processor command indentation}

\begin{verbatim}
// correct
#if HELLO_WORLD
#include "HellWorld.h"
#endif

// incorrect
#if HELLO_WORLD
#  include "HellWorld.h"
#endif
\end{verbatim}

\subsection{Pointers and references do not have prefixes}

\begin{verbatim}
// correct
MyClass* myClass1 = new MyClass();
MyClass& myClass2 = *myClass1;

// incorrect
MyClass* p_myClass1 = new MyClass();
MyClass& p_myClass2 = *p_myClass1;

// incorrect
MyClass* pMyClass1 = new MyClass();
MyClass& pMyClass2 = *pMyClass1;
\end{verbatim}

\subsection{The left comparator operand is a variable}

\begin{verbatim}
// correct
if (a == "hello world") {
  // ...
}

// incorrect
if ("hello world" == a) {
  // ...
}
\end{verbatim}

\subsection{The else statement on the same line as the curly brace}

\begin{verbatim}
// correct
if (a == b) {
  // ...
} else {
  // ...
}

// incorrect
if (a == b) {
  // ...
}
else {
  // ...
}
\end{verbatim}

\end{document}

\section{Design}

\subsection{Scope}

With a tool as conceptually simple as Synergy, it's very easy to get carried
away with feature requests. Some features we will \textbf{not include}:

\begin{enumerate}
  \item Dragging windows between screens.
  \item Remote audio sharing.
  \item Connecting over the Internet.
  \item Smart phone or tablet as server.
  \item Remote desktop integration.
\end{enumerate}

\subsection{GUI}

% TODO: Allow alternative config options:
% 1. chris' screen edge auto-config
% 2. manual drag and drop (there's been a lot of +1's for this)
% 3. load from file (so users can load v1, v2, or their own custom configs)

While version 1 is simple to setup, it can be a little difficult to
troubleshoot. As command-line tools go, the existing version is great, but
can be a little involved for some users. Often these users are from a Windows
or Mac background where tool configuration is usually done with an intuitive
GUI.

Version 1 was originally designed as a command line tool, then later on, several
GUI applications were invented to try and make configuration easier. QSynergy is
one of those GUIs that found a good balance of cross-platform support and user 
friendliness. However, like all Synergy GUIs, it is limited by the lack of 
interoperability with the underlying command line utility. So we should design 
version 2 with inter-process communication (IPC) to the GUI firmly in mind. 
Security is also an issue.

\subsection{Wizard}

While we should support the existing config file format, some would prefer a
setup wizard to simplify the process. The wizard should display immediately
after installation on all platforms (with the option to skip the wizard). When
the wizard starts, the user should choose whether the machine is a client or a
server (the wizard should explain the difference with a simple diagram).

% TODO: Replace steps with an activity/sequence diagram.

\subsubsection{Server steps}
\begin{enumerate}
  \item Show instructions for starting client wizard(s).
  \item Show connected clients in a status list (as they connect).
  \item Allow user to advance once all clients have connected.
  \item Allow user to drag and drop clients on a grid.
  \item Save config to file (at custom location) when complete.
\end{enumerate}

Often, the user's hostname will not be found on their DNS server, and in such
a case we should detect this, and ask the user to use an IP instead.

\subsubsection{Client steps}
\begin{enumerate}
  \item Prompt the user for the server hostname or IP (shown in server wizard).
  \item If unable to connect, show troubleshooting tips.
\end{enumerate}

Troubleshooting steps might include asking the user to temporarily turn off
their firewall, try pinging, etc. This will reduce the number of troubleshooting
requests coming into the website and mailing list.

\subsection{Auto Start}

With version 1, most users need to have some technical knowledge of their OS
in order to start synergy when their computer boots. This new version must
take care of starting at boot automatically in order to be more seamless.

As an example, in Linux Synergy 
must start at the init.d process, or at least immediately when the window 
manager starts, so that the user can use the login screen remotely.

\subsection{Keyboard}

% Chris says to only support key codes, not both chars and codes!
 
In version 1, key chars are sent over the network. This poses a nightmare when
it comes to multilingual support, or even just supporting new keys (e.g. media
keys, etc). It's easy to read key chars, and it's tempting to re-use this 
approach in version 2; however, it will only give us problems and bugs to fix,
when what we really need to do is support key codes.

What's so good about key codes? Instead of relaying the char that the user would
see typed in any other application, we relay the code of the key that is 
pressed, which is not be tied to any particular language. This means that a user
can type in English on computer A, and Russian on computer B without needing to
switch the language on the master. Instead, the user chooses the language on
the receiver.

There is a complication with key codes however; each operating system has it's
own set of key codes - so we need to map each key code to our own set, so that
key codes sent over the network are generic and can be translated to any 
platform.

\subsection{Network model}

We will support both server-client (traditional) and a new P2P model, as
described in this section.

\subsubsection{Server-client}

Historically, Synergy has always used a server-client model, where the server's
mouse and keyboard control the clients (figure \ref{fig:serverClient}). This is
actually the opposite to how remote access applications work, where the computer
being controlled is the server (not a client).

\begin{figure}[ht!]
  \centering
  \input diag/nd-serverclient.tex
  \caption{Server-client network model}
  \label{fig:serverClient}
\end{figure}

The computer with the mouse and keyboard must be online at all other times to
make the other computers useful (laptops excluded). To some degree, it makes 
sense to have this computer as the server, since the server should be online
at all times.

The disadvantage is that when the server computer goes offline, all other 
computers become somewhat redundant (until you physically plug a keyboard
and mouse into each of them). One solution is to allow any computer to be a 
aster or a slave...

\subsubsection{Peer-to-peer}

% this section is heavily based on this mailing list thread:
%   http://groups.google.com/group/synergy-plus-dev/browse_thread/thread/5a09353d55fc1364

Allowing any computer to be a master implies that any computer can control
any other computer. So you could have two computers with a mouse (e.g. a 
desktop and a laptop) and two without. See Figure \ref{fig:p2p}.

\begin{figure}[ht!]
  \centering
  \input diag/nd-p2p.tex
  \caption{P2P ``daisy-chain'' network model}
  \label{fig:p2p}
\end{figure}

% TODO: decide whether this anicdotal example should stay - is it helpful?

Why might this be useful? Let's say you've just arrived at the
office, with your laptop resumed from sleep - you sit down just in time to see
a 30 second restart countdown on your ``mouseless'' computer. Uh-oh, looks like
that new sys admin has decided to restart your workstation, great! No problem, 
just fire up your Synergy server machine and use Synergy to hit the abort 
button - but oh no, your server machine is running Windows and has decided to 
blue screen today. Your 2nd computer restarts and you've lost an entire night's
work because you forgot to hit save at 3am. Ok, so it's a bit of an edge-case
but you get the picture; some times it's a chore to turn your server on in
order to use your other computers.

We might be tempted to have each node connect to every other node, but
unfortunately this doesn't scale too well; the more connections you have, the
more that can go wrong making troubleshooting more difficult. Instead, we will
daisy chain all nodes together. Each node both listens to and connects to 
another node in the configuration, and messages are relayed around the daisy
chain to reach their final destination.

\subsubsection{The master mode}

So when does a node switch to master mode? One option might be to make this
automatic and triggered by mouse movement. The problem with this sort of
detection is that it's not always possible (depending on the platform) to
detect real (by a human) or ``fake'' (by Synergy) input. It might be the
case that some OSs can distinguish between real and fake input, but we cannot
always guarantee this to be the case. So, we should make master/slave switching
manual at the user's discretion. For example, if the user wishes for their
laptop to become the master, they can just use their laptop touch pad to
select master from their system tray icon (or command line, etc). It is
important that the user can do this while Synergy is running; having to restart
the program may make things complicated for the user.

\subsubsection{Introducing new nodes}

Setting up a daisy chain will probably be too much hassle for most users,
since they will first have to understand why, and then decide which computers
connect to what, and so on. It's much better to have this done automatically,
where the user has no knowledge of what the configuration really looks like.
We must however make the user aware that to use this ``automatic'' mode, all
computers must be on the same network. This means that a node must somehow
introduce it's self to the Synergy network (either when the user is setting 
up Synergy for the first time, or afterward when the node is established
as part of the network). We will use Bonjour to broadcast the node's IP address
and a port to which one other node can connect.

Each time a new node joins the Synergy network, all other nodes will be informed
of it's presence, and their internal IP-to-node mappings will be updated (in 
case they loose connection to a peer and need to connect to a new one).

Since we're using a daisy chain, this poses an interesting problem. How does
the sender know which hops to use? We might say that the IP-to-node mapping
also knows something about routes; each node in the mapping will also have two
peers (incoming and outgoing) -- think of a linked list. Using this graph,
the sender can figure out which route to take.

An automatically configured P2P network will work well on DHCP networks where
each computer could potentially have a new IP each time it reconnects (though
the rate at which IPs change is quite slow/predictable). Even so, this also 
means that the user need not have a valid DNS setup (which is a fairly common
problem). Many first-time users attempt to use only the hostname (which actually
resolves to nothing at all), then complain when they cannot connect. The answer
is always ``Use IP addresses instead,'' which needless to say, is very tiering.

\subsubsection{Security concerns}

Allowing any Synergy node to say ``Hey, I'm here, connect to me!'' introduces
a security dilemma. A malicious program could easily broadcast using Bonjour
pretending to be a real Synergy client. We should do two things to help prevent
this: first, have a configurable option to turn remote control on or off for
a particular node (we might turn this off by default, and allow users to turn
it on during configuration); secondly, messages can be encrypted (on by 
default).

If a node looses contact with it's peer, it will attempt to automatically fix
the problem in one of two ways (depending on whether the incoming or outgoing 
connection was lost). If the outgoing connection was dropped (i.e. the 
connection that the node has initiated) then it will attempt to connect each 
of the other known nodes in round-robin fashion until it finds a new peer. It 
will keep trying forever, or until the incoming connection drops (if this 
happens then we can assume that the IP-to-node mapping may be stale). If
the incoming connection drops, then the node will re-announce (and will keep
doing so forever), hoping that another Synergy node will eventually connect.

\subsubsection{Legacy support}

The disadvantage of P2P is that some users may have their server on one network
(behind a firewall) and a client on a restricted network (e.g. corporate wifi).
For this reason, we must still support client-server for such users who are 
less fortunate. Another reason to still support client-server is that users may
want to upgrade straight from version 1 to version 2 and use the same config 
file.

\subsection{Protocol}

Each key press and mouse delta will trigger a message sent over a simple TCP 
stream (see Table \ref{tab:messageFormat}).

\begin{table}
  \begin{tabular}{|l|l|l|l|l|}
    \hline
    \textbf{Pos} &
    \textbf{Part} &
    \textbf{Size} &
    \textbf{Type} &
    \textbf{Comment} \\
    \hline
    0 & Size & 4B & uint32\_t & The total message size in bytes. \\
    4 & Type & 2B & uint16\_t & See Table \ref{tab:messageTypes} for enum. \\
    6 & From & 2B & uint16\_t & Well known sender node ID. \\
    8 & To & 2B & uint16\_t & Well known recipient node ID. \\
    10 & Data & $\leq$4GB & char[] & An array of arbitrary binary data. \\
    \hline
  \end{tabular}
  \caption{TCP message format}
  \label{tab:messageFormat}
\end{table}

Encryption will be supported, and will be enabled by default. Cryptography may 
put a noticeable load on the CPU, so we must allow this to be turned on and off
(but on by default). The message as defined in Table \ref{tab:messageFormat}
can be wrapped in an encrypted message, but will have no knowledge of encryption
it's self.

\begin{table}
  \begin{tabular}{|l|l|l|}
    \hline
    \textbf{Type} &
    \textbf{Data} &
    \textbf{Detail} \\
    \hline
    HelloServer & Client key & Client message to server on connect. \\
    HelloClient & Access allowed? & Response to key authentication. \\
    KeyCodeDown & Key code & Generic HID key code (from keyboard). \\
    \hline
  \end{tabular}
  \caption{Message type enumeration (incomplete)}
  \label{tab:messageTypes}
\end{table}

\subsubsection{TCP multiplexing}

Clipboard data must also be sent over the same connection as mouse and
keyboard input. This is fine if the user has copied a small amount of data
such as a block of text; but what about images? Big problem! If Synergy is busy
sending a picture of of fluffy kittens, then user input relaying will suffer.
We could open a new connection specifically for clipboard data, but this idea
doesn't scale too well (more connections gives us a higher margin of error).
That said, having a separate connection, may work out as a cheap option
should we need one.

The best-practice solution is to implement TCP multiplexing, which will allow 
us to prioritize the messages that we send over a single connection. We
might achieve this by chunking messages and adding them to a prioritized queue,
where HID messages are immediately sent to the front. The receiver will then
be responsible for re-constructing the chunks into real messages. However,
we might want to be careful of chunking HID messages, since these need to be
more performant (the speed of sending clipboard data doesn't really matter).

\subsection{Configuration}

In server-client mode, the configuration will live on the server, just like in
version 1. We will also entirely support version 1 configurations. In fact, 
version 2 configuration file will be almost identical, but with a few added
options (e.g. to state whether or not the setup is client-server or P2P). We 
will not make version 2 configurations backward-compatible.

In P2P mode however, things get complicated. Each node must be aware of it's
neighbor in terms of physical screen location and network peering
(incidentally, there will be no correlation between the two, since network 
peering will be based on availability and network time proximity). So, in the
case of P2P, the configuration file will be shared. Since there can only be
one master active at a time, this machine is responsible for distributing
changes to the configuration file. Now that the configuration file is shared,
any machine can assume command of the ship, since it'll already know the layout
of the screens.

\clearpage
\subsection{UML}

\begin{figure}[ht!]
  \begin{center}
    \includegraphics{diag/cd-system.1}
    \caption{System class diagram, for server and client}
    \label{fig:systemClassDiagram}
  \end{center}
\end{figure}

\begin{figure}[ht!]
  \begin{center}
    \includegraphics{diag/cd-server.1}
    \caption{Server class diagram}
    \label{fig:serverClassDiagram}
  \end{center}
\end{figure}

\begin{figure}[ht!]
  \begin{center}
    \includegraphics{diag/cd-client.1}
    \caption{Client class diagram}
    \label{fig:clientClassDiagram}
  \end{center}
\end{figure}

\begin{table}[ht!]
  \begin{tabular}{|l|l|}
    \hline
    \textbf{Class} & \textbf{Purpose} \\
    \hline
    System & Common functionality between Client and Server. \\
    Server & Contains server-side code. \\
    Client & Contains client-side code. \\
    Screen & The entire viewable area, which could span many monitors. \\
    VirtualScreen & Represents what is displayed on each monitor. \\
    Device & A human input device (e.g. Mouse, Keyboard, Joystick). \\
    Mouse & Captures mouse input, representing the current state. \\
    Keyboard & Captures keyboard input, representing key states. \\
    DeviceRelay & Relays received human input from server to the OS. \\
    MouseRelay & Relays mouse movement to the OS. \\
    KeyboardRelay & Relays pressed keys to the OS. \\
    \hline
  \end{tabular}
  \caption{Class purpose definition}
  \label{tab:classes}
\end{table}

\begin{figure}
  \centering
  \input diag/sd-system.tex
  \caption{Server and client sequence diagram}
\end{figure}

\begin{figure}
  \centering
  \input diag/sd-clipboard.tex
  \caption{Clipboard sharing sequence diagram}
\end{figure}

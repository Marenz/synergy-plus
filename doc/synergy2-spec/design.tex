\section{Design}

\subsection{Scope}

With a tool as conceptually simple as Synergy, it's very easy to get carried
away with feature requests. Some features we will \textbf{not include}:

\begin{enumerate}
  \item Dragging windows between screens.
  \item Remote audio sharing.
  \item Connecting over the Internet.
  \item Smart phone or tablet as server.
  \item Remote desktop integration.
\end{enumerate}

\subsection{GUI}

While version 1 is simple to setup, it can be a little difficult to
troubleshoot. As command-line tools go, the existing version is great, but
can be a little involved for some users. Often these users are from a Windows
or Mac background where tool configuration is usually done with a GUI.

Version 1 was originally designed as a command line tool, then later on, several
GUI applications were invented to try and make configuration easier. QSynergy is
one of those GUIs that found a good balance of cross-platform support and user 
friendliness. However, like all Synergy GUIs, it is limited by the lack of 
interoperability with the underlying command line utility. So we should design 
version 2 with inter-process communication (IPC) to the GUI firmly in mind. 
Security is also an issue; we need to make sure a malicious program can't
connect to Synergy via the IPC layer (perhaps a shared key will be sufficient).

With this version, we aim to make configuration extremely simple so that anyone
can use Synergy without having to know anything about IPs or which machine is a
server or a client. One setup option will be that the user can use a wizard (see
Figure \ref{fig:setupWizard}). The wizard should include an ``online'' manual 
with a troubleshooting section. Troubleshooting steps might include asking the 
user to temporarily turn off their firewall, try pinging, etc. This will reduce
the number of troubleshooting requests coming into the website and mailing list.
The user will can always drag and drop screens into the designer (instead of
using the edge-hit feature) just in case the edge-hit feature fails to work
correctly.

When starting the wizard, the user will choose between two options: Simple (a
guided process, which is very easy to use, and creates a P2P network); and
Advanced, which allows the user to load a config file -- this makes it possible
to setup a sever-client configuration, or lead a version 1 config.

\clearpage
\begin{figure}[ht!]
  \centering
  \includegraphics{diag/ad-wizard.1}
  \caption{Setup wizard}
  \label{fig:setupWizard}
\end{figure}

\subsubsection{Place screens anywhere}

While the version 1 configuration syntax does allow for screens to be placed at
positions relative to each other, most (if not all) GUIs so far have not 
considered this. In version 2 we will allow the user to drag screens anywhere
(on the layout designer) so that you can have (for example) two small screens
stacked next to a large screen.

\subsection{Run at startup}

With version 1, most users need to have some technical knowledge of their OS
in order to start synergy when their computer boots. This new version must
take care of starting at boot automatically in order to be more seamless.

Autostart on linux is exceptionally difficult because different versions linux 
require different configurations. In particular autostarting after the X server
starts requires editing shell scripts. Maybe we can start via init.d and poll 
for a running X server.

\subsection{Keyboard}

In version 1, key chars are sent over the network. This poses a nightmare when
it comes to multilingual support, or even just supporting new keys (e.g. media
keys, etc). It's easy to read key chars, and it's tempting to re-use this 
approach in version 2; however, it will only give us problems and bugs to fix,
when what we really need to do is support key codes.

What's so good about key codes? Instead of relaying the char that the user would
see typed in any other application, we relay the code of the key that is 
pressed, which is not be tied to any particular language. This means that a user
can type in English on computer A, and Russian on computer B without needing to
switch the language on the master. Instead, the user chooses the language on
the receiver.

There is a complication with key codes however; each operating system has its
own set of key codes - so we need to map each key code to our own set, so that
key codes sent over the network are generic and can be translated to any 
platform.

\subsection{Network model}

We will support both server-client (traditional) and a new P2P model, as
described in this section.

\subsubsection{Server-client}

Historically, Synergy has always used a server-client model, where the server's
mouse and keyboard control the clients (figure \ref{fig:serverClient}). This is
actually the opposite to how remote access applications work, where the computer
being controlled is the server (not a client).

\begin{figure}[ht!]
  \centering
  \input diag/nd-serverclient.tex
  \caption{Server-client network model}
  \label{fig:serverClient}
\end{figure}

The computer with the mouse and keyboard must be online at all other times to
make the other computers useful (laptops excluded). To some degree, it makes 
sense to have this computer as the server, since the server should be online
at all times.

The disadvantage is that when the server computer goes offline, all other 
computers become somewhat redundant (until you physically plug a keyboard
and mouse into each of them). One solution is to allow any computer to be a 
aster or a slave...

\subsubsection{Peer-to-peer}

% TODO: drop ``daisy chain'' idea in favour of ``hub'' approach.

% this section is heavily based on this mailing list thread:
%   http://groups.google.com/group/synergy-plus-dev/browse_thread/thread/5a09353d55fc1364

Allowing any computer to be a master implies that any computer can control
any other computer. So you could have two computers with a mouse (e.g. a 
desktop and a laptop) and two without. See Figure \ref{fig:p2p}.

\begin{figure}[ht!]
  \centering
  \input diag/nd-p2p.tex
  \caption{P2P ``daisy-chain'' network model}
  \label{fig:p2p}
\end{figure}

Why might this be useful? Let's say you've just arrived at the
office, with your laptop resumed from sleep - you sit down just in time to see
a 30 second restart countdown on your ``mouseless'' computer. Uh-oh, looks like
that new sys admin has decided to restart your workstation, great! No problem, 
just fire up your Synergy server machine and use Synergy to hit the abort 
button - but oh no, your server machine is running Windows and has decided to 
blue screen today. Your 2nd computer restarts and you've lost an entire night's
work because you forgot to hit save at 3am. Ok, so it's a bit of an edge-case
but you get the picture; some times it's a chore to turn your server on in
order to use your other computers.

We might be tempted to have each node connect to every other node, but
unfortunately this doesn't scale too well; the more connections you have, the
more that can go wrong making troubleshooting more difficult. Instead, we will
daisy chain all nodes together. Each node both listens to and connects to 
another node in the configuration, and messages are relayed around the daisy
chain to reach their final destination.

\subsubsection{The master mode}

So when does a node switch to master mode? One option might be to make this
automatic and triggered by mouse movement. The problem with this sort of
detection is that it's not always possible (depending on the platform) to
detect real (by a human) or ``fake'' (by Synergy) input. It might be the
case that some OSs can distinguish between real and fake input, but we cannot
always guarantee this to be the case. So, we should make master/slave switching
manual at the user's discretion. For example, if the user wishes for their
laptop to become the master, they can just use their laptop touch pad to
select master from their system tray icon (or command line, etc). It is
important that the user can do this while Synergy is running; having to restart
the program may make things complicated for the user.

\subsubsection{Introducing new nodes}

Setting up a daisy chain will probably be too much hassle for most users,
since they will first have to understand why, and then decide which computers
connect to what, and so on. It's much better to have this done automatically,
where the user has no knowledge of what the configuration really looks like.
We must however make the user aware that to use this ``automatic'' mode, all
computers must be on the same network. This means that a node must somehow
introduce itself to the Synergy network (either when the user is setting 
up Synergy for the first time, or afterward when the node is established
as part of the network). We will use Bonjour to broadcast the node's IP address
and a port to which one other node can connect.

Each time a new node joins the Synergy network, all other nodes will be informed
of its presence, and their internal IP-to-node mappings will be updated (in 
case they lose connection to a peer and need to connect to a new one).

Since we're using a daisy chain, this poses an interesting problem. How does
the sender know which hops to use? We might say that the IP-to-node mapping
also knows something about routes; each node in the mapping will also have two
peers (incoming and outgoing) -- think of a linked list. Using this graph,
the sender can figure out which route to take.

An automatically configured P2P network will work well on DHCP networks where
each computer could potentially have a new IP each time it reconnects (though
the rate at which IPs change is quite slow/predictable). Even so, this also 
means that the user need not have a valid DNS setup (which is a fairly common
problem). Many first-time users attempt to use only the hostname (which actually
resolves to nothing at all), then complain when they cannot connect. The answer
is always ``Use IP addresses instead,'' which needless to say, is very tiring.

\subsubsection{Security concerns}

Allowing any Synergy node to say ``Hey, I'm here, connect to me!'' introduces
a security dilemma. A malicious program could easily broadcast using Bonjour
pretending to be a real Synergy client. We should do two things to help prevent
this: first, have a configurable option to turn remote control on or off for
a particular node (we might turn this off by default, and allow users to turn
it on during configuration); secondly, messages can be encrypted (on by 
default).

If a node loses contact with its peer, it will attempt to automatically fix
the problem in one of two ways (depending on whether the incoming or outgoing 
connection was lost). If the outgoing connection was dropped (i.e. the 
connection that the node has initiated) then it will attempt to connect each 
of the other known nodes in round-robin fashion until it finds a new peer. It 
will keep trying forever, or until the incoming connection drops (if this 
happens then we can assume that the IP-to-node mapping may be stale). If
the incoming connection drops, then the node will re-announce (and will keep
doing so forever), hoping that another Synergy node will eventually connect.

\subsubsection{Legacy support}

The disadvantage of P2P is that some users may have their server on one network
(behind a firewall) and a client on a restricted network (e.g. corporate wifi).
For this reason, we must still support client-server for such users who are 
less fortunate. Another reason to still support client-server is that users may
want to upgrade straight from version 1 to version 2 and use the same config 
file.

\subsection{Protocol}

Each key press and mouse delta will trigger a message sent over a simple TCP 
stream (see Table \ref{tab:messageFormat}).

\begin{table}[ht!]
  \begin{tabular}{|l|l|l|l|l|}
    \hline
    \textbf{Pos} &
    \textbf{Part} &
    \textbf{Size} &
    \textbf{Type} &
    \textbf{Comment} \\
    \hline
    0 & Size & 4B & uint32\_t & The total message size in bytes (inc header). \\
    4 & Type & 2B & uint16\_t & See Table \ref{tab:messageTypes} for enum. \\
    6 & From & 2B & uint16\_t & Runtime enerated sender node ID. \\
    8 & To & 2B & uint16\_t & Runtime generated recipient node ID. \\
    10 & Mux ch. & 1B & uint8\_t & TCP multiplex channel. \\
    12 & Payload & $<$4GB & char[] & The payload (a mux chunk). \\
    \hline
  \end{tabular}
  \caption{TCP message format}
  \label{tab:messageFormat}
\end{table}

Initially we will have 4 TCP multiplex channels (each of different priority), 
but this protocol allows us to have up to 255. We could use an unsigned nibble 
instead of a unsigned byte, but for the sake of saving 4 bits, this seems risky.

Encryption will be supported, and will be enabled by default. Cryptography may 
put a noticeable load on the CPU, so we must allow this to be turned on and off
(but on by default). The message as defined in Table \ref{tab:messageFormat}
can be wrapped in an encrypted message, but will have no knowledge of encryption
itself.

% TODO: turn question into statement!
Security requires not just encryption but also authentication. We should choose
or suggest appropriate standards for these. Do we allow various encryption and
authentication schemes? If so we must define a handshake to negotiate them.

\begin{table}[ht!]
  \begin{tabular}{|l|l|l|}
    \hline
    \textbf{Type} &
    \textbf{Data} &
    \textbf{Detail} \\
    \hline
    HelloServer & Client key & Client message to server on connect. \\
    HelloClient & Access allowed? & Response to key authentication. \\
    KeyCodeDown & Key code & Generic HID\footnotemark key code (from 
    keyboard). \\
    \hline
  \end{tabular}
  \caption{Message type enumeration (incomplete)}
  \label{tab:messageTypes}
\end{table}

\footnotetext{Human input device}

\subsubsection{TCP multiplexing}

Clipboard data must also be sent over the same connection as mouse and
keyboard input. This is fine if the user has copied a small amount of data
such as a block of text; but what about images? Big problem! If Synergy is busy
sending a picture of of fluffy kittens, then user input relaying will suffer.
We could open a new connection specifically for clipboard data, but this idea
doesn't scale too well (more connections gives us a higher margin of error).
That said, having a separate connection, may work out as a cheap option
should we need one.

The best-practice solution is to implement TCP multiplexing, which will allow 
us to prioritize the messages that we send over a single connection. We
might achieve this by chunking messages and adding them to a prioritized queue,
where human input device (HID) messages are immediately sent to the front. The
receiver will then be responsible for re-constructing the chunks into real 
messages. However, we might want to be careful of chunking HID messages, since 
these need to be more performant (the speed of sending clipboard data doesn't 
really matter).

\begin{table}[ht!]
  \begin{tabular}{|1|1|1|}
    \textbf{Pos} &
    \textbf{Part} &
    \textbf{Size} &
    \textbf{Type} &
    \textbf{Comment} \\
    \hline
    0 & Size & 2B & uint16\_t & The chunk size in bytes (inc header). \\
    2 & ID & 2B & uint16\_t & The chunk ID (sequential number). \\
    4 & Payload & $<$64KB & char[] & The chunk payload (binary data). \\
    \hline
  \end{tabular}
  \caption{TCP multiplex chunk}
  \label{tab:muxChunkFormat}
\end{table}

Each TCP multiplex chunk (see Table \ref{tab:muxChunkFormat}) will be 
encapsulated within a standard TCP message (see Table \ref{tab:messageFormat})
as the payload. Because there is maximum of 65535 chunks, each of 64KB in
size, a multiplexed message can be up to 4GB (which ties in nicely with
the maximum payload size).

We could define the TCP multiplex chunk format as part of the primary message
format (Table \ref{tab:messageFomrat}) but it might be a good idea to keep these
separate for two reasons: so that the protocol is more extensible; and so that
we can send a whole TCP message to the multiplexer component, which takes care
of chunking for us. Some further discussion may be needed here.

\subsection{Configuration}

In server-client mode, the configuration will live on the server, just like in
version 1. We will also entirely support version 1 configurations. In fact, 
version 2 configuration file will be almost identical, but with a few added
options (e.g. to state whether or not the setup is client-server or P2P). We 
will not make version 2 configurations backward-compatible.

In P2P mode however, things get complicated. Each node must be aware of its
neighbor in terms of physical screen location and network peering
(incidentally, there will be no correlation between the two, since network 
peering will be based on availability and network time proximity). So, in the
case of P2P, the configuration file will be shared. Since there can only be
one master active at a time, this machine is responsible for distributing
changes to the configuration file. Now that the configuration file is shared,
any machine can assume command of the ship, since it'll already know the layout
of the screens.

\clearpage
\subsection{UML}

\begin{figure}[ht!]
  \begin{center}
    \includegraphics{diag/cd-system.1}
    \caption{System class diagram, for server and client}
    \label{fig:systemClassDiagram}
  \end{center}
\end{figure}

\begin{figure}[ht!]
  \begin{center}
    \includegraphics{diag/cd-server.1}
    \caption{Server class diagram}
    \label{fig:serverClassDiagram}
  \end{center}
\end{figure}

\begin{figure}[ht!]
  \begin{center}
    \includegraphics{diag/cd-client.1}
    \caption{Client class diagram}
    \label{fig:clientClassDiagram}
  \end{center}
\end{figure}

\begin{table}[ht!]
  \begin{tabular}{|l|l|}
    \hline
    \textbf{Class} & \textbf{Purpose} \\
    \hline
    System & Common functionality between Client and Server. \\
    Server & Contains server-side code. \\
    Client & Contains client-side code. \\
    Screen & The entire viewable area, which could span many monitors. \\
    VirtualScreen & Represents what is displayed on each monitor. \\
    Device & A human input device (e.g. Mouse, Keyboard, Joystick). \\
    Mouse & Captures mouse input, representing the current state. \\
    Keyboard & Captures keyboard input, representing key states. \\
    DeviceRelay & Relays received human input from server to the OS. \\
    MouseRelay & Relays mouse movement to the OS. \\
    KeyboardRelay & Relays pressed keys to the OS. \\
    \hline
  \end{tabular}
  \caption{Class purpose definition}
  \label{tab:classes}
\end{table}

\begin{figure}
  \centering
  \input diag/sd-system.tex
  \caption{Server and client sequence diagram}
\end{figure}

\begin{figure}
  \centering
  \input diag/sd-clipboard.tex
  \caption{Clipboard sharing sequence diagram}
\end{figure}
